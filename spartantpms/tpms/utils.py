import sdf
from sdf.mesh import _estimate_bounds, _cartesian_product
import numpy as np
from typing import Optional, Tuple


def to_voxels(
    sdf: sdf.d3.SDF3,
    mesh_ct: Optional[int] = 101,
    bounds: Optional[Tuple[Tuple[float]]] = None,
) -> np.array:
    """Get the porosity (fraction of volume that is empyt space) of a structure defined by a signed distance function (sdf).

    Optionally provide a mesh density and dimensional bounds over which to evaluate the porosity of the sdf.

    Args:
        sdf (sdf.d3.SDF3): A signed distance function structure object, generated by the sdf package.
        mesh_ct (int, optional): _description_. Defaults to 101.
        bounds (Optional[Tuple[Tuple[float]]], optional): _description_. Defaults to None.

    Returns:
        np.array: 3-D boolean array of voxels
    """
    if bounds is None:
        bounds = _estimate_bounds(sdf)
    (x0, y0, z0), (x1, y1, z1) = bounds
    X = np.linspace(x0, x1, mesh_ct)
    Y = np.linspace(y0, y1, mesh_ct)
    Z = np.linspace(z0, z1, mesh_ct)

    P = _cartesian_product(X, Y, Z)
    return (sdf(P) <= 0).reshape(mesh_ct, mesh_ct, mesh_ct)


def get_porosity(
    sdf: sdf.d3.SDF3,
    mesh_ct: Optional[int] = 101,
    bounds: Optional[Tuple[Tuple[float]]] = None,
) -> float:
    """Get the porosity (fraction of volume that is empyt space) of a structure defined by a signed distance function (sdf).

    Optionally provide a mesh density and dimensional bounds over which to evaluate the porosity of the sdf.

    Args:
        sdf (sdf.d3.SDF3): A signed distance function structure object, generated by the sdf package.
        mesh_ct (int, optional): _description_. Defaults to 101.
        bounds (Optional[Tuple[Tuple[float]]], optional): _description_. Defaults to None.

    Returns:
        float: pore fraction (0-1) of the structure
    """
    voxels = to_voxels(sdf, mesh_ct, bounds)
    return 1 - np.mean(voxels)
